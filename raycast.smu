type cstr = ptr(u8)

-- We use printing functions of libc
-- Schmu does not have varargs, so we hardcode for 1 int
external printf : (cstr, int) -> unit
external puts : cstr -> unit

external sqrt : float -> float

external rand_max : unit -> int
external rand : unit -> int

-- these types would belong in a prelude, but that does not exist yet for schmu
type string = { cstr : cstr, length : int }
type vector('a) = {
  mutable data : ptr('a),
  mutable length : int,
  mutable capacity : int
}

type v3 = { x : float, y : float, z : float }
type point = v3
type color = v3
type ray = { orig : point, dir : v3 }
type hit_record = { p : point, normal : v3, t : float, front_face : bool }
-- We don't have variants yet, so we make an extra return record
type hit_return = { hit : bool, record : hit_record }

type sphere = { center : point, radius : float }

type camera = {
  origin : point,
  lower_left_corner : point,
  horizontal : v3,
  vertical : v3
}

-- There is no float_max_value yet :)
infinity = 340282346640000000000000000000000000.0
-- Constant for case of no hit
no_hit = {
  hit = false,
  record = {
    p = { x = 0.0, y = 0.0, z = 0.0 },
    normal = { x = 0.0, y = 0.0, z = 0.0 },
    t = infinity,
    front_face = false
  }
}

-- C stdlib wrappers
-- Wrap these functions so we don't need to write `.cstr` all the time
fun pi(str, i)
  printf(str.cstr, i)
end

fun ps(str)
  puts(str.cstr)
end

fun random_float()
  -- Returns a random float in [0, 1)
  float_of_int(rand()) /. (float_of_int(rand_max()) +. 1.0)
end

fun random_range(min, max)
  -- Returns a random float in [min, max)
  min +. ((max -. min) *. random_float())
end

-- vector functions
fun vector_init(size)
  -- __malloc is a builtin, the compiler will free once the ptr
  -- drops out of scope. (Or, in this case, when the scope the ptr is
  -- returned to ends)
  ptr = __malloc(size)
  { data = ptr, length = 0, capacity = size }
end

fun vector_push(vec, val)
  if vec.length == vec.capacity then
    cap = vec.capacity * 2
    vec.data <- __realloc(vec.data, cap)
    vec.capacity <- cap
  else () end
  __unsafe_ptr_set(vec.data, vec.length, val)
  vec.length <- vec.length + 1
end

fun vector_iter(vec, f)
  fun inner(i)
    if i == vec.length then
      ()
    else
      f(__unsafe_ptr_get(vec.data, i))
      inner(i+1)
    end
  end
  inner(0)
end

fun vector_fold(vec, f, init)
  fun inner(i, acc)
    if i == vec.length then
      acc
    else
      acc = f(acc, __unsafe_ptr_get(vec.data, i))
      inner(i+1, acc)
    end
  end
  inner(0, init)
end

-- v3 functions
fun v3_add(lhs, rhs)
  { x = lhs.x +. rhs.x, y = lhs.y +. rhs.y, z = lhs.z +. rhs.z }
end

fun v3_sub(lhs, rhs)
  { x = lhs.x -. rhs.x, y = lhs.y -. rhs.y, z = lhs.z -. rhs.z }
end

fun v3_scale(v3, factor)
  { x = v3.x *. factor, y = v3.y *. factor, z = v3.z *. factor }
end

fun v3_div(v3, factor)
  { x = v3.x /. factor, y = v3.y /. factor, z = v3.z /. factor }
end

fun v3_dot(lhs, rhs)
  (lhs.x *. rhs.x) +. (lhs.y *. rhs.y) +. (lhs.z *. rhs.z)
end

fun v3_norm(v3)
  length = v3_dot(v3, v3) -> sqrt
  v3_div(v3, length)
end

fun v3_random_range(min, max)
  {
    x = random_range(min, max),
    y = random_range(min, max),
    z = random_range(min, max)
  }
end

fun v3_random_in_unit_sphere()
  p = v3_random_range(0.0 -. 1.0, 1.0)
  if v3_dot(p, p) <. 1.0 then p
  else v3_random_in_unit_sphere() end
end

fun v3_random_unit_v3()
  v3_random_in_unit_sphere() -> v3_norm()
end

-- utility
fun clamp(x, min, max)
  if x <. min then min
  elseif x >. max then max
  else x end
end

-- color functions
fun write_color(color, samples_per_pixel)
  scale = 1.0 /. samples_per_pixel
  -- pseudo gamma correction
  r = sqrt(color.x *. scale)
  g = sqrt(color.y *. scale)
  b = sqrt(color.z *. scale)

  pi("%i ", (clamp(r, 0.0, 0.999) *. 256.0) -> int_of_float)
  pi("%i ", (clamp(g, 0.0, 0.999) *. 256.0) -> int_of_float)
  pi("%i\n", (clamp(b, 0.0, 0.999) *. 256.0) -> int_of_float)
end

-- ray functions
fun ray_at(ray, t)
  v3_scale(ray.dir, t) -> v3_add(ray.orig)
end

-- camera functions
fun camera_get_ray(camera, u, v)
  dir = v3_add(camera.lower_left_corner, v3_scale(camera.horizontal, u))
     -> v3_add(v3_scale(camera.vertical, v)) -> v3_sub(camera.origin)
  { orig = camera.origin, dir = dir }
end

-- sphere collision function
fun hit_sphere(sphere, ray, t_min, t_max)
  fun outside(root)
    root <. t_min or t_max <. root
  end

  oc = ray.orig -> v3_sub(sphere.center)
  a = v3_dot(ray.dir, ray.dir)
  half_b = v3_dot(oc, ray.dir)
  c = v3_dot(oc, oc) -. (sphere.radius *. sphere.radius)

  discriminant = (half_b *. half_b) -. (a *. c)

  if discriminant <. 0.0 then
    no_hit
  else
    sqrtd = sqrt(discriminant)

    -- Find the nearest root that lies in the acceptable range
    -- Helper function to return a root
    fun return_root(root)
      p = ray_at(ray, root)
      outward_normal = v3_sub(p, sphere.center) -> v3_div(sphere.radius)
      front_face = v3_dot(ray.dir, outward_normal) <. 0.0
      normal = if front_face then outward_normal
               else v3_scale(outward_normal, 0.0 -. 1.0) end

      { hit = true,
        record = {
          t = root,
          p = p,
          normal = normal,
          front_face = front_face
        }
      }
    end

    root = (0.0 -. half_b -. sqrtd) /. a
    if outside(root) then
      root = (0.0 -. half_b +. sqrtd) /. a
      if outside(root) then
        no_hit
      else
        return_root(root)
      end
    else
      return_root(root)
    end
  end
end

-- World collision function
fun hit_world(world, ray, t_min)
  -- NOTE If I leave the unused t_max in, there are
  -- problems with monomorphization
  vector_fold(world, fun(acc, sphere)
    hit = hit_sphere(sphere, ray, t_min, acc.record.t)
    if hit.hit then hit
    else acc end
  end,
  no_hit)
end

-- Returns the color of a given ray
fun ray_color(ray, world, depth)
  if depth == 0 then
    -- No light is gathered
    { x = 0.0, y = 0.0, z = 0.0 }
  else
    hit = hit_world(world, ray, 0.001)
    if hit.hit then
      target = v3_add(hit.record.p, hit.record.normal)
        -> v3_add(v3_random_unit_v3())
      ray = { orig = hit.record.p, dir = v3_sub(target, hit.record.p) }
      -- no tail call
      v3_scale(ray_color(ray, world, depth - 1), 0.5)
    else
      unit_dir = v3_norm(ray.dir)
      t = 0.5 *. (unit_dir.y +. 1.0)
      -- lerp
      v3_scale({ x = 1.0, y = 1.0, z = 1.0 }, (1.0 -. t) *. 1.0)
      -> v3_add(v3_scale({ x = 0.5, y = 0.7, z = 1.0 }, t *. 1.0))
    end
  end
end

-- image
aspect_ratio = 16.0 /. 9.0
image_width = 400
image_height = int_of_float(float_of_int(image_width) /. aspect_ratio)
samples_per_pixel = 100
recursion_depth = 50

-- camera
viewport_height = 2.0
viewport_width = aspect_ratio *. viewport_height
focal_length = 1.0

origin = { x = 0.0, y = 0.0, z = 0.0 }
horizontal = { x = viewport_width, y = 0.0, z = 0.0 }
vertical = { x = 0.0, y = viewport_height, z = 0.0 }
lower_left_corner = v3_sub(origin, v3_div(horizontal, 2.0))
                 -> v3_sub(v3_div(vertical, 2.0))
                 -> v3_sub({ x = 0.0, y = 0.0, z = focal_length })
-- we really need name punning here
cam = {
  origin = origin,
  lower_left_corner = lower_left_corner,
  horizontal = horizontal,
  vertical = vertical
}

-- world
world = vector_init(2)
vector_push(world, { center = { x = 0.0, y = 0.0, z = 0.0 -. 1.0 }, radius = 0.5 })
vector_push(world, { center = { x = 0.0, y = 0.0 -. 100.5, z = 0.0 -. 1.0 }, radius = 100.0 })

fun render(width, height)
  if width == image_width then
    render(0, height - 1)
  elseif height < 0 then -- The book does it this way, so we follow suit
    ()
  else
    fun loop_samples(color, i)
      if i == samples_per_pixel then
        color
      else
        u = (float_of_int(width) +. random_float())
          /. float_of_int(image_width - 1)
        v = (float_of_int(height) +. random_float())
          /. float_of_int(image_height - 1)

        ray = camera_get_ray(cam, u, v)
        color = ray_color(ray, world, recursion_depth) -> v3_add(color)
        loop_samples(color, i + 1)
      end
    end

    no_color = { x = 0.0, y = 0.0, z = 0.0 }
    color = loop_samples(no_color, 0)

    write_color(color, samples_per_pixel -> float_of_int)

    -- recurse
    render(width + 1, height)
  end
end

fun write_header()
  ps("P3")
  pi("%i ", image_width)
  pi("%i\n", image_height)
  ps("255")
end

write_header()
render(0, image_height - 1)
